import inspect

import yaml
from pydantic import Field
from typing import List, Union, Optional, Callable

from mas_arena.agent_flow.model_configs import LLMConfig
from mas_arena.core_serializer.parser import Parser
from mas_arena.utils.serialization_utils import get_type_name, parse_json_from_text, parse_xml_from_text, parse_data_from_text

PARSER_VALID_MODE = ["str", "json", "xml", "title", "custom"]

class LLMOutputParser(Parser):
    content: str = Field(default=None, exclude=True, description="the text generated by LLM")

    @classmethod
    def get_attrs(cls, return_type: bool = False) -> List[Union[str, tuple]]:
        """Returns the attributes of the LLMOutputParser class.

        Excludes ["class_name", "content"] by default.

        Args:
            return_type: Whether to return the type of the attributes along with their names.

        Returns:
            If `return_type` is True, returns a list of tuples where each tuple contains
            the attribute name and its type. Otherwise, returns a list of attribute names.
        """
        attrs = []
        exclude_attrs = ["class_name", "content"]
        for field, field_info in cls.model_fields.items():
            if field not in exclude_attrs:
                if return_type:
                    field_type = get_type_name(field_info.annotation)
                    attrs.append((field, field_type))
                else:
                    attrs.append(field)
        return attrs

    @classmethod
    def get_attr_descriptions(cls) -> dict:
        """Returns the attributes and their descriptions.

        Returns:
            A dictionary mapping attribute names to their descriptions.
        """
        attrs = cls.get_attrs()
        results = {}
        for field_name, field_info in cls.model_fields.items():
            if field_name not in attrs:
                continue
            field_desc = field_info.description if field_info.description is not None else "None"
            results[field_name] = field_desc
        return results

    @classmethod
    def get_content_data(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None,
                         **kwargs) -> dict:
        """Parses LLM-generated content into a dictionary.

        This method takes content from an LLM response and converts it to a structured
        dictionary based on the specified parsing mode.

        Args:
            content: The content to parse.
            parse_mode: The mode to parse the content. Must be one of:
                - 'str': Assigns the raw text content to all attributes of the parser.
                - 'json': Extracts and parses JSON objects from LLM output. It will return a dictionary parsed from the first valid JSON string.
                - 'xml': Parses content using XML tags. It will return a dictionary parsed from the XML tags.
                - 'title': Parses content with Markdown-style headings.
                - 'custom': Uses custom parsing logic. Requires providing `parse_func` parameter as a custom parsing function.
            parse_func: The function to parse the content, only valid when parse_mode is 'custom'.
            **kwargs (Any): Additional arguments passed to the parsing function.

        Returns:
            The parsed content as a dictionary.

        Raises:
            ValueError: If parse_mode is invalid or if parse_func is not provided when parse_mode is 'custom'.
        """
        attrs = cls.get_attrs()
        if len(attrs) <= 0:
            return {}

        if parse_mode == "str":
            parse_func = cls._parse_str_content
        elif parse_mode == "json":
            parse_func = cls._parse_json_content
        elif parse_mode == "xml":
            parse_func = cls._parse_xml_content
        elif parse_mode == "title":
            parse_func = cls._parse_title_content
        elif parse_mode == "custom":
            if parse_func is None:
                raise ValueError("`parse_func` must be provided when `parse_mode` is 'custom'.")
            # obtain the function inputs
            signature = inspect.signature(parse_func)
            if "content" not in signature.parameters:
                raise ValueError("`parse_func` must have an input argument `content`.")

            func_args = {}
            func_args["content"] = content
            for param_name, param in signature.parameters.items():
                if param_name == "content":
                    continue  # Already set
                if param_name in kwargs:
                    func_args[param_name] = kwargs[param_name]
            data = parse_func(**func_args)
            if not isinstance(data, dict):
                raise ValueError(f"The output of `parse_func` must be a dictionary, but found {type(data)}.")
            return data
        else:
            raise ValueError(
                f"Invalid value '{parse_mode}' detected for `parse_mode`. Available choices: {PARSER_VALID_MODE}")
        data = parse_func(content=content, **kwargs)
        return data

    @classmethod
    def _parse_str_content(cls, content: str, **kwargs) -> dict:
        """Parses content by setting all attributes to the raw content.

        Args:
            content: The content to parse.
            **kwargs: Additional arguments (not used).

        Returns:
            A dictionary mapping all attributes to the raw content.
        """
        # if `parse_mode=str` in llm.generate(), it will set all the defined parameters to `content`
        attrs = cls.get_attrs()
        return {attr: content for attr in attrs}

    @classmethod
    def _parse_json_content(cls, content: str, **kwargs) -> dict:
        """Parses content by extracting and parsing a JSON object.
        If the content contains multiple JSON objects, only the first one will be used.

        Args:
            content: The content containing a JSON object.
            **kwargs: Additional arguments (not used).

        Returns:
            The parsed JSON as a dictionary.

        Raises:
            ValueError: If the content doesn't contain a valid JSON object.
        """
        extracted_json_list = parse_json_from_text(content)
        if len(extracted_json_list) > 0:
            json_str = extracted_json_list[0]  # only use the first JSON
            try:
                data = yaml.safe_load(json_str)
                if not isinstance(data, dict):
                    if isinstance(data, list):
                        # LLM returns a list of JSON strings, without specifying the attribute name
                        attrs = cls.get_attrs()
                        if len(attrs) == 1:
                            # if there is only one attribute, use it as the attribute name
                            return {attrs[0]: data}
                        else:
                            # if there are multiple attributes, raise an error
                            raise ValueError(
                                "The generated content is a list of JSON strings, but the attribute name for the list is not specified. You should instruct the LLM to specify the attribute name for the list.")
                    else:
                        raise ValueError(f"The generated content is not a valid JSON string:\n{json_str}")
            except Exception:
                raise ValueError(f"The generated content is not a valid JSON string:\n{json_str}")
        else:
            raise ValueError(f"The following generated content does not contain JSON string!\n{content}")

        return data

    @classmethod
    def _parse_xml_content(cls, content: str, **kwargs) -> dict:
        """Parses content by extracting values from XML tags.

        Each attribute of the parser is expected to be enclosed in XML tags
        with the attribute name as the tag name.

        Args:
            content: The content containing XML tags.
            **kwargs: Additional arguments (not used).

        Returns:
            A dictionary mapping attributes to their extracted values.

        Raises:
            ValueError: If the content is missing expected XML tags or if the
                        extracted values can't be converted to the expected types.
        """
        attrs_with_types: List[tuple] = cls.get_attrs(return_type=True)
        data = {}
        for attr, attr_type in attrs_with_types:
            attr_raw_value_list = parse_xml_from_text(text=content, label=attr)
            if len(attr_raw_value_list) > 0:
                attr_raw_value = attr_raw_value_list[0]
                try:
                    attr_value = parse_data_from_text(text=attr_raw_value, datatype=attr_type)
                except Exception:
                    raise ValueError(f"Cannot parse text: {attr_raw_value} into {attr_type} data!")
            else:
                raise ValueError(
                    f"The following generated content does not contain xml label <{attr}>xxx</{attr}>!\n{content}")
            data[attr] = attr_value
        return data

    @classmethod
    def _parse_title_content(cls, content: str, title_format: str = "## {title}", **kwargs) -> dict:
        """Parses content with markdown-style titles.

        Extracts sections from content that are divided by titles following
        the specified format described in `title_format`. The default format is "## {title}".
        For example:
        ```
        ## title1
        content1
        ## title2
        content2
        ```
        This content will be parsed into:
        ```
        {
            "title1": "content1",
            "title2": "content2"
        }
        ```
        Args:
            content: The content with title-divided sections.
            title_format: The format of the titles, default is "## {title}".
            **kwargs: Additional arguments (not used).

        Returns:
            A dictionary mapping title names to their section contents.
        """
        attrs: List[str] = cls.get_attrs()
        if not attrs:
            return {}

        output_titles = [title_format.format(title=attr) for attr in attrs]

        def is_output_title(text: str):
            for title in output_titles:
                if text.strip().lower().startswith(title.lower()):
                    return True, title
            return False, None

        data = {}
        current_output_name: str = None
        current_output_content: list = None
        for line in content.split("\n"):
            is_title, title = is_output_title(line)
            if is_title:
                if current_output_name is not None and current_output_content is not None:
                    data[current_output_name] = "\n".join(current_output_content)
                current_output_content = []
                current_output_name = title.replace("#", "").strip()
                output_titles.remove(title)
            else:
                if current_output_content is not None:
                    current_output_content.append(line)
        if current_output_name is not None and current_output_content is not None:
            data[current_output_name] = "\n".join(current_output_content)
        return data

    @classmethod
    def parse(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None,
              **kwargs) -> "LLMOutputParser":
        """Parses LLM-generated text into a structured parser instance.

        This is the main method for creating parser instances from LLM output.

        Args:
            content: The text generated by the LLM.
            parse_mode: The mode to parse the content, must be one of:
                - 'str': Assigns the raw text content to all attributes of the parser.
                - 'json': Extracts and parses JSON objects from LLM output. Uses the first valid JSON string to create an instance of LLMOutputParser.
                - 'xml': Parses content using XML tags. Uses the XML tags to create an instance of LLMOutputParser.
                - 'title': Parses content with Markdown-style headings. Uses the Markdown-style headings to create an instance of LLMOutputParser. The default title format is "## {title}", you can change it by providing `title_format` parameter, which should be a string that contains `{title}` placeholder.
                - 'custom': Uses custom parsing logic. Requires providing `parse_func` parameter as a custom parsing function. The `parse_func` must have a parameter named `content` and return a dictionary where the keys are the attribute names and the values are the parsed data.
            parse_func: The function to parse the content, only valid when `parse_mode` is 'custom'.
            **kwargs (Any): Additional arguments passed to parsing functions, such as:
                - `title_format` for `parse_mode="title"`.

        Returns:
            An instance of LLMOutputParser containing the parsed data.

        Raises:
            ValueError: If parse_mode is invalid or if content is not a string.
        """
        if parse_mode not in PARSER_VALID_MODE:
            raise ValueError(
                f"'{parse_mode}' is an invalid value for `parse_mode`. Available choices: {PARSER_VALID_MODE}.")
        if not isinstance(content, str):
            raise ValueError(f"The input to {cls.__name__}.parse should be a str, but found {type(content)}.")
        data = cls.get_content_data(content=content, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        data.update({"content": content})
        parser = cls.from_dict(data, **kwargs)
        return parser

    def __str__(self) -> str:
        """
        Returns a string representation of the parser.
        """
        return self.to_str()

    def to_str(self, **kwargs) -> str:
        """
        Converts the parser to a string.
        """
        return self.content

    def get_structured_data(self) -> dict:
        """Extracts structured data from the parser.

        Returns:
            A dictionary containing only the defined attributes and their values,
            excluding metadata like class_name.
        """
        attrs = type(self).get_attrs()
        data = self.to_dict(ignore=["class_name"])
        # structured_data = {attr: data[attr] for attr in attrs}
        structured_data = {key: value for key, value in data.items() if key in attrs}
        return structured_data

__all__ = ["LLMConfig", "LLMOutputParser"]
